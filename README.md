# WGS

## Steps

### Step 1
From raw sequence data to SNPs -> [Sequence processing](https://github.com/Cpetak/WGS/blob/main/sequence_processing.md)

### Step 2
From temporal pH and temperature data to scaled mean and variability -> [Environmental data processing](https://github.com/Cpetak/WGS/blob/main/env_data_processing.R)

### Step 3
Converting the output of ANGSD with the SNPs into the format Bayenv expects -> [Converting for Bayenv](https://github.com/Cpetak/WGS/blob/main/bayenv_conversion.py)

### Step 4
Estimating covarience matrix and Bayenv factors -> [Running Bayenv](https://github.com/Cpetak/WGS/blob/main/Running_bayenv.md)

### Step 5
Generating dataframe with Bayenv factor, number of neighbors, expression level and SNP number -> [Feature engineering](https://github.com/Cpetak/WGS/blob/main/get_gene_from_snp.ipynb)

### Step 6
Exploring and modeling variables -> [Playing with variables](https://github.com/Cpetak/WGS/blob/main/playing_with_variables-new.ipynb)

## Files in repo
**all_mapping_stats.csv** -> All mapping statistics generated by flagstat, including Paired/Num.reads, Coverage, and Total reads.

**annotation.txt, filtered_annotation.gff** -> Chr, start and stop position for every urchin gene. Downloaded from NCBI (as gff, v5.0), only rows labelled "gene" were kept.

**bayenv_conversion.py** -> Converting the output of ANGSD with the SNPs (mafs) into the format Bayenv expects. I introduced some potentially unwanted biases here!

**bayenv_env.txt, env_vars.csv, bayenv_input.xlsx** -> bayenv_env.txt and env_vars.csv include normalised means of 5 environmental variables for the 6 populations. These were calculated in Step 2 and they were normalised in bayenv_input.xlsx. These were the values used for Bayenv.

**big_df_allvars.csv** -> output of Step 5.

**CombinedCounts_NotNormalized.txt** -> Transcriptomics data from Melissa.(Evans et al., 2017) Nothing was altered.

**env_data_processing.R** -> Environmental data was copied from http://data.bco-dmo.org/jg/serv/BCO/OMEGAS/Moorings_Temp_pH.brev0. Mean, standard deviation and frequency of pH under 7.8 was calculated and exported for each site belonging to our populations.

**flagstat.R** -> Visualising flagstat results.

**further_quick_check.ipynb** -> playing with the output of Step 5, big_df_allvars.csv. For example, checked what genes high Bayenv factors belonged to.

**get_gene_from_snp.ipynb** -> code doing Step 5.

**multiqc_report folder, multiqc_report.html** -> Multiqc combining all fastqc results.

**pca_pops_noout.txt, pca_pops.txt** -> List of individuals with their corresponding population with and without PCA outliers. Needed for some visualsiations with R.

**ph_pca_noout.txt, ph_pca.txt** -> Same as above but instead of population name it is whether they experience low (L) or high (H) pH variability.

**playing_with_variables-new.ipynb** -> Code doing Step 6.

**reduced_network.csv** -> Edge table including only p-p interactions with 999 confidence score. Original file was downloaded from the String DB.

**snpsfile_100_pos.txt, snpsfile_1000_pos.txt** -> Positions of SNPs that were selected as input to Bayenv, every 100th and every 1000th from the original SNP file.

**sorted_results_100, sorted_results_1000** -> Bayenv outputs, each line contains the Bayenv factor of the SNP corresponding to the SNP in the above file. (Order is retained).

**SPU_LOC_conv.txt** -> Downloaded from String DB, conversion between the old SPU and the new LOC tags of urchin genes.

**string-db-mining.ipynb** -> Scraping the String DB. Wasn't used in the end, instead whole network file was downloaded and processed.

**DS_final_project.pdf** -> Document summarising all steps, my Data Science I final paper.
